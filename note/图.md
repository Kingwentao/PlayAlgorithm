### 图的存储方式

#### 1.邻接矩阵存储方法

特性：邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1

优点很明显：首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。
其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。
比如求解最短路径问题时会提到一个 Floyd-Warshall（弗洛伊德） 算法，就是利用矩阵循环相乘若干次得到结果。

缺点： 如果我们存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。
比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。
如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。

#### 2.邻接表存储方法

特性： 有向图的邻接表存储方式是，每个顶点对应一条链表，链表中存储的是与这个顶点指向的其他顶点。
对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。

优点：邻接表存储起来比较节省空间，

缺点：因为使用的是链表结构，所以要遍历顶点对应的链表，比较耗时间。

但是链表的查询效率可以改进：

比如将邻接表中的链表改成平衡二叉查找树。 实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。
当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。
除此之外， 我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。

### 图的遍历

1. 广度遍历: 使用链表+hash表记录
2. 深度遍历：使用栈+hash表记录

> 图的创建和遍历，见`Graph`类

#### 拓扑排序

拓扑排序常用来确定一个依赖关系集中，事物发生的顺序。
例如，在日常工作中，将项目拆分成A、B、C、D四个子部分来完成，但A依赖于B和D，C依赖于D。 
为了计算这个项目进行的顺序，可对这个关系集进行拓扑排序，得出一个线性的序列，则排在前面的任务就是需要先完成的任务。

排序算法核心思路：根据依赖关系，构建出图结构，然后找到入度为0的结点，加入排序结果数组中，并对被依赖它的结点入度-1。
以此类推，不断寻找入度为0的结点加入排序结果数组中。

> 算法详见`TopologySort`

#### 深度和广度优先搜索

算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。
**图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。**

**1.广度优先搜索**

广度优先搜索即先查找离起始顶点最近的，然后是次近的，依次往外搜索。

时间复杂度：最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。
这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，
所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。
当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为 O(E)。

空间复杂度：广度优先搜索的空间消耗主要在几个辅助变量，这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。

**2.深度优先搜索**

深度优先搜索（Depth-First-Search），简称 DFS。

深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现

> 搜索算法详见`GraphSearch`