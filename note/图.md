### 图的存储方式

#### 1.邻接矩阵存储方法

特性：邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1

优点很明显：首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。
其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。
比如求解最短路径问题时会提到一个 Floyd-Warshall（弗洛伊德） 算法，就是利用矩阵循环相乘若干次得到结果。

缺点： 如果我们存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。
比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。
如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。

#### 2.邻接表存储方法

特性： 有向图的邻接表存储方式是，每个顶点对应一条链表，链表中存储的是与这个顶点指向的其他顶点。
对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。

优点：邻接表存储起来比较节省空间，

缺点：因为使用的是链表结构，所以要遍历顶点对应的链表，比较耗时间。

但是链表的查询效率可以改进：

比如将邻接表中的链表改成平衡二叉查找树。 实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。
当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。
除此之外， 我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。

### 图的遍历

1. 广度遍历: 使用链表+hash表记录
2. 深度遍历：使用栈+hash表记录

> 图的创建和遍历，见`Graph`类

#### 拓扑排序

拓扑排序常用来确定一个依赖关系集中，事物发生的顺序。
例如，在日常工作中，将项目拆分成A、B、C、D四个子部分来完成，但A依赖于B和D，C依赖于D。 
为了计算这个项目进行的顺序，可对这个关系集进行拓扑排序，得出一个线性的序列，则排在前面的任务就是需要先完成的任务。

排序算法核心思路：根据依赖关系，构建出图结构，然后找到入度为0的结点，加入排序结果数组中，并对被依赖它的结点入度-1。
以此类推，不断寻找入度为0的结点加入排序结果数组中。

> 算法详见`TopologySort`