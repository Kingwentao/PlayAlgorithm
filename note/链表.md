### 链表

- 单链表：单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。
- 双向链表：双向链表支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。
- 循环链表：循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。

双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点。双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

1. 插入：**删除给定指针指向的结点**。
   因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。
   所以，针对此情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了
2. 查询：对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。
   每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。
3. 与数据的最大区别：
   链表本身没有大小的限制，天然地支持动态扩容。如果申请的数组过小，就只能再申请一个更大的内存空间，把原数组拷贝进去，而数据拷贝的操作是非常耗时的。

> 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。
> CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块
> 并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。
> 这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。
> 对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。

检查链表代码是否正确的边界条件有这样几个：
1. 如果链表为空时，代码是否能正常工作？
2. 如果链表只包含一个结点时，代码是否能正常工作？
3. 如果链表只包含两个结点时，代码是否能正常工作？
4. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

> 写链表代码是最考验逻辑思维能力的。链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。
> 链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因

|           题目            |               代码中类名(leetcode address)               | 
| :-----------------------: | :----------------------------------------------------------: | 
| 138.复制带随机指针的链表 | [CopyRandomList](https://leetcode-cn.com/problems/copy-list-with-random-pointer/) | 
| 86.分隔链表 | [PartitionList](https://leetcode-cn.com/problems/partition-list/) | 
| 234.回文链表  | [IsPalindrome](https://leetcode-cn.com/problems/palindrome-linked-list/)   |   
| 142.环形链表II   |  [DetectCycle](https://leetcode-cn.com/problems/linked-list-cycle-ii/)  |
| 两个单链表（可成环形）相交  |  [MeetLinkedList](https://cloud.tencent.com/developer/article/1606344)  |